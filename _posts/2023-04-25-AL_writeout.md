---
layout: post
title: "AL:깜지"
categories: [lecture]
---

## 강좌의 목표

### 설계(Design)

알고리즘을 설계하는 여러 가지 기법을 배운다

### 분석(Analysis)

알고리즘의 효율을 나타내는 시간/공간 복잡도를 구하기 위해 알고리즘을 분석하는 방법을 배운다.

### 계산적 복잡도 (Computational Complexity)

문제를 분석하여 계산적 복잡도를 구하는 방법을 배운다.

## 알고리즘(Algorithm)의 정의

몇 가지 간단한 정의

- 문제에 대한 답을 찾기 위하여 계산하는 절차

- 단계별로 주의 깊게 설계된 계산과정

- 입력을 받아서 출력으로 전환시켜주는 일련의 계산절차

보다 정교한 정의

- 문제를 해결하기 위한, 각 단계가 명확하게 정의되고 실행이 가능한 일련의 절차

Why not "Method or Scheme or Procedure or Step"?

요구 조건

- 유한시간 내 종료

- 명확성

- 실행 가능성

- 기타

8-9세기 페르시아의 수학자 Al-Khwarizmi의 이름에서 유래

## 프로그램 설계 과정

문제 --설계--> 알고리즘 --분석--> 만족? ----> 프로그램

(만족하지 않으면 재설계)

## 알고리즘의 이용

"I can thumb right to the C's to find Collen Collie's number." (Barney Beagle)

## 알고리즘의 예

문제: 전화번호부에서 '홍길동'의 전화번호 찾기

알고리즘

- 순차검색: 첫 쪽부터 홍길동이라는 이름이 나올 때까지 순서대로 찾는다.

- 수정된 이분검색: 전화번호부는 "가나다"순으로 되어 있으므로 먼저 "ㅎ"이 있을 만한 곳으로 넘겨본 후 앞뒤로 뒤적여가며 찾는다.

분석: 어떤 알고리즘이 더 좋은가?

## 문제의 표기 방법

문제: 답을 찾고자 던지는 질문

파라미터: 문제에서 특정값이 주어지지 않은 변수

문제의 사례(입력): 파라미터에 특정 값을 지정한 것

사례에 대한 해답(출력): 주어진 사례에 관한 질문에 대한 답

## 문제의 표기 방법 예: 검색

문제: n개의 수로 된 리스트 S에 x라는 수가 있는지 알아내시오. x가 S에 있으면 '예', 없으면 '아니오'로 답하시오.

파라미터: S, n, x

입력의 예: S=\[10, 7, 11, 5, 3, 8\], n=6, x=5

출력의 예: '예'

## 알고리즘의 표기

표기 방법

- 자연어: 한글 또는 영어 => 자연어의 특징인 모호성, 중의성 때문에 복잡한 알고리즘의 표기에는 적합하지 않음

- 프로그래밍 언어: C, C++, Java, ML 등 => 특정 언어의 기능에 신경을 쓰느라 알고리즘에 집중하기 어려움

- 의사코드(Pseudo-code)
    
    직접 실행할 수 있는 프로그래밍 언어는 아니지만 거의 실제 프로그램에 가깝게 계산과정을 표현할 수 있는 언어

알고리즘은 보통 의사코드로 표현한다.

이 강의에서는 C++에 가까운 의사코드를 사용한다.

## C++와 의사코드의 차이점(1/3)

배열 인덱스의 범위에 제한 없음

- C++는 반드시 0부터 시작
    
- 의사코드는 임의의 값 사용 가능

프로시저의 파라미터에 2차원 배열 크기의 가변성 허용

지역 배열에 변수 인덱스 허용

수학적 표현식 허용

C++ 에 없는 타입 사용 가능

제어구조

프로시저와 함수

참조 파라미터(reference parameter)를 사용하여 프로시저의 결과값 전달

- 배열: 참조 파라미터로 전달

- 기타: 데이터 타입 이름 뒤에 &를 붙임

- const 배열: 전달되는 배열의 값이 불변

## 순차검색(Sequential Search) 알고리즘

문제: 크기가 n인 배열 S에 x가 있는가?

입력(파라미터): (1) 양수 n, (2) 배열 S, (3) 키 x

출력: x가 S에 포함되어 있다면 그 위치. 만약 없으면 0.

### 알고리즘(자연어)

x와 같은 아이템을 찾을 때까지 S에 있는 모든 아이템을 차례로 검사한다.

만일 x와 같은 아이템을 찾으면 S에서 위치를 내주고, S를 모두 검사하고도 찾지 못하면 0을 내준다.

### 자연어로 기술된 알고리즘의 문제점

차례로? => 1, 2, ..., n의 순서? 아니면...

## 순차검색 알고리즘의 의사코드 표기

```cpp
void seqserch(int n, const keytype S[], keytype x, index& location) {
    location = 1;
    while(location <= n && S[location] != x)
        location++;
    if(location > n)
        location = 0;
}
```

while-루프: 아직 검사할 항목이 있고, x를 찾지 못했나?

if-문: 모두 검사하였으나, x를 찾지 못했나?

## 순차검색 알고리즘의 고찰

순차검색 알고리즘으로 키를 찾기 위해서 S에 있는 항목을 몇 개나 검색해야 하는가?

- 키와 같은 항목의 위치에 따라 다름

- 최악의 경우: n

좀 더 빨리 찾을 수는 없는가?

- S에 있는 항목에 대한 정보가 없는 한 더 빨리 찾을 수 없다.

Let's think about this:

    "Is the linear search really an inefficient algorithm?"

## 이분검색(Binary Search) 알고리즘

문제: 크기가 n인 정렬된 배열 S에 x가 있는가?

입력: 양수n, 배열S, 키x

출력: x가 S에 포함되어 있다면 그 위치. 만약 없으면 0

## 이분검색 알고리즘의 의사코드 표기

```cpp
void binsearch(int n, const keytype S[], keytype x, index& location) {
    index low, high, mid;
    low = 1; high = n;
    location = 0;
    while(low <= high && location == 0) {
        mid = (low + high) / 2;
        if(x == S[mid]) location = mid;
        else if(x < S[mid]) high = mid - 1;
        else low = mid + 1;
    }
}
```

while-루프: 아직 검사할 항목이 있고, x를 찾지 못했나?

이분검색 알고리즘으로 키를 찾기 위해서 S에 있는 항목을 몇 개나 검색해야 하는가?

while문을 수행할 때마다 검색 대상의 총 크기가 반 씩 감소하기 때문에 최악의 경우라도 lg n + 1개만 검사하면 된다.

## n 번째 피보나찌(Fibonacci) 수 구하기

피보나찌 수열의 정의

f0 = 0

f1 = 1

fn = fn-1 + fn-2 for n>=2

### 재귀적 방법

문제: n번째 피보나찌 수를 구하라.

입력: 양수n

출력: n번째 피보나찌 수

알고리즘

```cpp
int fib(int n) {
    if(n <= 1)
        return n;
    else
        return fib(n-1)+fib(n-2);
}
```

피보나찌 수 구하기 재귀 알고리즘은 수행 속도가 매우 느리다.

이유: 같은 피보나찌 수를 중복 계산

### fib(n)의 함수 호출 횟수 계산

T(n) = fib(n)을 계산하기 위하여 fib 함수를 호출하는 횟수 즉, 재귀 트리 상의 마디(node) 수

T(0) = 1

T(1) = 1

T(n) = T(n-1) + T(n-2) + 1

\> 2 * T(n-2)

\> 2^2 * T(n-4)

...

\> 2^(n/2)

### 반복적 방법

알고리즘

```cpp
int fib2(int n) {
    index i;
    int f[0..n];
    f[0] = 0;
    if(n > 0) {
        f[1] = 1;
        for(i = 2; i <= n; i++)
            f[i] = f[i-1]+f[i-2];
    }
    return f[n];
}
```

고찰

반복알고리즘은 수행속도가 훨씬 더 빠르다.

이유: 중복계산이 없음

계산하는 항의 총 개수

T(n) = n + 1

즉, f\[0\]부터 f\[n\]까지 한 번씩만 계산

## 알고리즘의 분석

시간복잡도(Time Complexity) 분석

- 입력 크기에 따라서 단위연산이 몇 번 수행되는지 결정하는 절차

표현 척도

- 단위연산(basic operation): 비교, 지정 등

- 입력크기(input size): 배열의 크기, 리스트의 길이, 행렬에서 행과 열의 크기, 트리에서 마디(node)와 이음선(edge)의 수 등

## 알고리즘 분석 방법의 종류

- 모든 경우 분석(Evey-case analysis)

    - 입력 크기에만 종속
    
    - 입력 값과는 무관하게 결과 값은 항상 일정

- 최악 경우 분석(Worst-case analysis)

    - 입력 크기와 입력 값 모두에 종속
    
    - 단위 연산이 수행되는 횟수가 최대인 경우 선택

- 평균 경우 분석(Average-case analysis)

    - 입력 크기와 입력 값 모두에 종속
    
    - 모든 입력에 대해서 단위연산이 수행되는 기대치(평균)

    - 각 입력에 대해서 확률 할당 가능
    
    - 일반적으로 최악의 경우보다 계산이 복잡

- 최선 경우 분석(Best-case analysis)

    - 입력 크기와 입력 값 모두에 종속
    
    - 단위 연산이 수행되는 횟수가 최소인 경우 선택

## 알고리즘 분석의 예: 배열 덧셈

문제: 크기가 n인 배열 S의 모든 수를 더하라

입력: 양수 n, 배열 S

출력: 배열 S에 있는 모든 수의 합

알고리즘

```cpp
number sum(int n, const number S[]) {
    index i;
    number result;

    result = 0;
    for (i = 1; i <= n; i++)
        result = result + S[i];
    return result;
}
```

시간복잡도 분석

1. 단위연산: 덧셈

    입력크기: 배열의 크기 n

    모든 경우 분석
    
    - 배열 내용에 상관없이 for-루프가 n번 반복된다.
    
    - 각 루프마다 덧셈이 1회 수행된다.

    - 따라서, n에 대해서 덧셈이 수행되는 총 횟수는 T(n) = n이다.

2. 단위연산: 지정문(for-루프의 첨자 지정문 포함)

    입력크기: 배열의 크기 n

    모든 경우 분석
    
    - 배열 내용에 상관없이 for-루프가 n번 반복된다.

    - 따라서, 지정문이 T(n) = n + n + 1번 수행된다.

## 알고리즘 분석의 예: 교환 정렬(Exchange Sort)

문제: 비내림차순으로 n개의 키를 정렬

입력: 양수n, 배열S

출력: 비내림차순으로 정렬된 배열

알고리즘

```cpp
void exchangesort(int n, keytype S[]) {
    index i, j;

    for(i = 1; i <= n-1; i++)
        for(j = i+1; j <= n; j++)
            if(S[j] < S[i])
                exchange S[i] and S[j];
}
```

### 시간복잡도 분석 1

단위연산: 조건문(S\[j\]와 S\[i\]의 비교)

입력크기: 정렬할 항목의 수 n

모든 경우 분석:

- j-루프가 수행될 때마다 조건문 1번씩 수행

- 조건문의 총 수행 횟수: T(n) = (n-1) + (n-2) + ... + 1 = ((n-1)n)/2

### 시간복잡도 분석 2

단위연산: 교환하는 연산(exchange S[j] and S[i])

입력크기: 정렬할 항목의 수 n

최악 경우 분석:

- 조건문의 결과에 따라서 교환 연산의 수행 여부가 결정된다.

- 최악 경우: 조건문이 항상 참(true)이 되는 경우, 입력 배열이 거꾸로 정렬되어 있는 경우

T(n) = (n-1) + (n-2) + ... + 1 = ((n-1)n)/2

## 순차 검색 알고리즘의 최악 경우 시간복잡도 분석

단위연산: 배열의 아이템과 키 x와의 비교 연산 (S[location] != x)

입력크기: 배열 안에 있는 아이템의 수 n

### 최악 경우 분석:

- x가 배열의 마지막 아이템이거나, x가 배열에 없는 경우 단위연산이 n번 수행된다.

- 따라서, W(n) = n

순차 검색 알고리즘의 경우 입력 배열의 값에 따라서 검색하는 횟수가 달라지므로, 모든 경우 분석은 불가능하다.

### 평균 경우 분석:

- 배열의 아이템이 모두 다르다고 가정한다.

- 경우 1(x가 배열 S 안에 있는 경우만 고려)

    - 1 < k < n에 대해서 x가 배열의 k번째에 있을 확률 1/n

    - x가 배열의 k번째에 있다면, x를 찾기 위해서 수행하는 단위연산의 횟수 k

    - 따라서, (n+1)/2

- 경우 2(x가 배열 S안에 없는 경우도 고려)

    - x가 배열 S 안에 있을 확률을 p라고 하면,
    
        - x가 배열의 k번째에 있을 확률 = p/n
        
        - x가 배열에 없을 확률 = 1-p

    - 따라서 