---
layout: default
title: (골드3) BOJ 1719번 C++ 풀이
parent: 알고리즘 코딩테스트 - C++
last_modified_date: 2024-04-26
---

# BOJ BOJ 1719번 C++ 풀이

## 문제

### [택배](https://www.acmicpc.net/problem/1719){:target="_blank"}

## 풀이

[다익스트라](/algorithm/note/2024-04-23-dijkstra){:target="_blank"} 알고리즘을 써야 하는 문제

최단거리 경로 중 가장 처음 방문하는 노드를 기록해야 한다는 점이 독특하다.

result 배열에 각 노드의 최단거리 경로 중 가장 처음 방문하는 노드를 기록하는데, 이 result 배열을 참고하여 가장 처음 방문하는 노드를 알아낼 수 있다.

유니온 파인드의 개념과 함께 생각해 보면 이해하기가 쉬웠다.

## 결과 코드

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

int main() {
  int n, m;
  cin >> n >> m;

  vector<vector<int> > result;
  vector<int> dist;
  vector<vector<pair<int, int> > > edge;

  result.assign(n+1, vector<int>());
  // result 배열 초기화 -> 각 방과 인덱스를 동일하게
  for(int i = 0; i < n+1; i++) {
    for(int j = 0; j < n+1; j++)
      result[i].push_back(j);
  }
  edge.assign(n+1, vector<pair<int, int> >());

  for(int i = 0; i < m; i++) {
    // edge 채우기
    int s, e, w;
    cin >> s >> e >> w;

    edge[s].push_back(make_pair(e, w));
    edge[e].push_back(make_pair(s, w));
  }

  // 다익스트라 각 노드마다 진행
  for(int i = 1; i < n+1; i++) {
    dist.assign(n+1, INT_MAX);
    dist[i] = 0;

    priority_queue<pair<int, int> > pq;
    pq.push(make_pair(0, i));
    while(!pq.empty()) {
      int node = pq.top().second;
      pq.pop();

      for(int j = 0; j < edge[node].size(); j++) {
        int next = edge[node][j].first;
        int d = edge[node][j].second;

        if(dist[next] > dist[node] + d) {
          dist[next] = dist[node] + d;
          pq.push(make_pair(-d, next));
          // result 배열 채우기
          // 한 번에 갈 수 있는 노드는 i == node 이다
          if(i != node) result[i][next] = result[i][node];
        }
      }
    }
  }

  // 출력
  for(int i = 1; i < n+1; i++) {
    for(int j = 1; j < n+1; j++) {
      if(i == j) cout << "- ";
      else cout << result[i][j] << " ";
    }
    cout << "\n";
  }
}
```